# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CIwOW0w9eB44JY_ROYoKPj86oNQR14Mb
"""
@st.cache_data
def load_custom_data():
    # Remove '/content/' and use the simple name
    df = pd.read_csv('data.csv') 
    
    # Get the latest status for each bin
    latest = df.sort_values('timestamp').groupby('bin_id').tail(1)
    return latest


import streamlit as st
import pandas as pd
import osmnx as ox
import networkx as nx
import folium
from streamlit_folium import st_folium
import qrcode
from io import BytesIO

# --- CONFIGURATION ---
st.set_page_config(page_title="Smart Waste Optimizer", layout="wide")

# 1. LOAD YOUR DATA
@st.cache_data
def load_custom_data():
    df = pd.read_csv('/content/cleaned_data_with_fuel_weight_co2 (1).csv')
    # Get the latest status for each bin
    latest = df.sort_values('timestamp').groupby('bin_id').tail(1)
    return latest

df_latest = load_custom_data()

# 2. FILTER BINS THAT NEED COLLECTION
# Let's say we only collect bins that are more than 75% full
full_bins = df_latest[df_latest['bin_fill_percent'] > 75].copy()

st.title("ðŸš› Smart Waste Management: AI Route Optimizer")
st.write(f"Found **{len(full_bins)}** bins that require immediate collection (>75% full).")

# 3. LOAD MAP NETWORK (MUMBAI REGION)
@st.cache_resource
def get_mumbai_graph():
    # Centering around the average lat/lon of your bins
    center_lat = 19.04
    center_lon = 72.86
    # Downloading road network (5km radius to cover your data points)
    return ox.graph_from_point((center_lat, center_lon), dist=5000, network_type='drive')

G = get_mumbai_graph()

# 4. CALCULATE SHORTEST PATH (TSP Approximation)
# We find the closest road nodes for our "Full Bins"
nodes = [ox.nearest_nodes(G, row['bin_location_lon'], row['bin_location_lat'])
         for idx, row in full_bins.iterrows()]

# Create a simple sequential route (A -> B -> C)
full_route = []
for i in range(len(nodes)-1):
    try:
        path = nx.shortest_path(G, nodes[i], nodes[i+1], weight='length')
        full_route.extend(path[:-1] if i < len(nodes)-2 else path)
    except nx.NetworkXNoPath:
        continue

# 5. FIXED VISUALIZATION (Avoiding the AttributeError)
# Create a Folium Map
m = folium.Map(location=[19.04, 72.86], zoom_start=13, tiles="cartodbpositron")

# Add the route as a PolyLine
if full_route:
    route_coords = [[G.nodes[n]['y'], G.nodes[n]['x']] for n in full_route]
    folium.PolyLine(route_coords, color="#2ecc71", weight=5, opacity=0.8).add_to(m)

# Add markers for the Bins
for idx, row in full_bins.iterrows():
    folium.Marker(
        location=[row['bin_location_lat'], row['bin_location_lon']],
        popup=f"Bin {row['bin_id']}: {row['bin_fill_percent']}% Full",
        icon=folium.Icon(color='red' if row['bin_fill_percent'] > 90 else 'orange', icon='trash')
    ).add_to(m)

# Display Map
st_folium(m, width="100%", height=500)

# 6. QR CODE FOR NAVIGATION
st.subheader("ðŸ“² Driver Navigation")
# Generate a Google Maps multi-stop link
base_url = "https://www.google.com/maps/dir/"
coords_str = "/".join([f"{row['bin_location_lat']},{row['bin_location_lon']}" for idx, row in full_bins.iterrows()])
nav_link = base_url + coords_str

qr = qrcode.make(nav_link)
buf = BytesIO()
qr.save(buf)
st.image(buf, width=200, caption="Scan to open route in Google Maps")



